import streamlit as st
import pandas as pd
import numpy as np
from database import get_stored_tickers, get_db_connection
from fees import get_fee_params, apply_fees

def render_backtest_ui():
    st.header("Moving Average Crossover Backtest (5min, from May 1st 2025)")
    stored_tickers = get_stored_tickers()
    if stored_tickers:
        selected_ticker_bt = st.selectbox("Select Ticker for Backtest", options=stored_tickers, key='selected_ticker_bt')
        if st.button("Run Backtest"):
            con = get_db_connection()
            query = f"""
                SELECT * FROM stock_prices 
                WHERE ticker = '{selected_ticker_bt}' AND interval = '5minute' AND datetime >= '2025-05-01'
                ORDER BY datetime ASC
            """
            try:
                df_bt = con.execute(query).fetchdf()
            except Exception as e:
                st.error(f"Error fetching data: {e}")
                df_bt = pd.DataFrame()
            con.close()
            if df_bt.empty:
                st.warning("No 5min data from May 1st 2025 for this ticker.")
            if not df_bt.empty:
                df_bt['ma20'] = df_bt['close'].rolling(window=20).mean()
                df_bt['ma50'] = df_bt['close'].rolling(window=50).mean()
                df_bt['signal'] = 0
                # Fix pandas chained assignment warning
                df_bt.loc[20:, 'signal'] = np.where(df_bt.loc[20:, 'ma20'] > df_bt.loc[20:, 'ma50'], 1, 0)
                df_bt['position'] = df_bt['signal'].diff()
                trades = []
                position = None
                entry_price = None
                entry_time = None
                trade_profits = []
                trade_profits_after_fees = []
                trade_fees = []
                fee_params = get_fee_params()
                for idx, row in df_bt.iterrows():
                    if row['position'] == 1:
                        if position is None:
                            position = 'long'
                            entry_price = row['close']
                            entry_time = row['datetime']
                            trades.append((row['datetime'], 'BUY', row['close']))
                    elif row['position'] == -1:
                        if position == 'long':
                            exit_price = row['close']
                            trades.append((row['datetime'], 'SELL', exit_price))
                            pnl = exit_price - entry_price
                            trade_value = entry_price + exit_price
                            pnl_after_fees, total_fees = apply_fees(pnl, trade_value, 'SELL', fee_params)
                            trade_profits.append(pnl)
                            trade_profits_after_fees.append(pnl_after_fees)
                            trade_fees.append(total_fees)
                            position = None
                            entry_price = None
                            entry_time = None
                if position == 'long' and entry_price is not None:
                    exit_price = df_bt.iloc[-1]['close']
                    trades.append((df_bt.iloc[-1]['datetime'], 'SELL', exit_price))
                    pnl = exit_price - entry_price
                    trade_value = entry_price + exit_price
                    pnl_after_fees, total_fees = apply_fees(pnl, trade_value, 'SELL', fee_params)
                    trade_profits.append(pnl)
                    trade_profits_after_fees.append(pnl_after_fees)
                    trade_fees.append(total_fees)
                st.subheader("Trade Log")
                if trades:
                    trade_df = pd.DataFrame(trades, columns=['datetime', 'action', 'price'])
                    # Align P&L columns with SELL rows only
                    n = len(trade_df)
                    pnl_before_fees_col = [None] * n
                    fees_col = [None] * n
                    pnl_after_fees_col = [None] * n
                    sell_idx = 0
                    for i, row in trade_df.iterrows():
                        if row['action'] == 'SELL':
                            pnl_before_fees_col[i] = trade_profits[sell_idx]
                            fees_col[i] = trade_fees[sell_idx]
                            pnl_after_fees_col[i] = trade_profits_after_fees[sell_idx]
                            sell_idx += 1
                    trade_df['pnl_before_fees'] = pnl_before_fees_col
                    trade_df['fees'] = fees_col
                    trade_df['pnl_after_fees'] = pnl_after_fees_col
                    st.dataframe(trade_df)
                else:
                    st.info("No trades generated by the strategy.")
                st.subheader("Performance Metrics")
                num_trades = len(trade_profits)
                wins = sum(1 for p in trade_profits_after_fees if p > 0)
                win_rate = (wins / num_trades * 100) if num_trades > 0 else 0
                total_pnl = sum(trade_profits)
                total_pnl_after_fees = sum(trade_profits_after_fees)
                total_fees = sum(trade_fees)
                avg_pnl = (total_pnl / num_trades) if num_trades > 0 else 0
                avg_pnl_after_fees = (total_pnl_after_fees / num_trades) if num_trades > 0 else 0
                st.markdown(f"**Number of Trades:** {num_trades}")
                st.markdown(f"**Win Rate (after fees):** {win_rate:.2f}%")
                st.markdown(f"**Total P&L (before fees):** {total_pnl:.2f}")
                st.markdown(f"**Total Fees:** {total_fees:.2f}")
                st.markdown(f"**Total P&L (after fees):** {total_pnl_after_fees:.2f}")
                st.markdown(f"**Average P&L per Trade (before fees):** {avg_pnl:.2f}")
                st.markdown(f"**Average P&L per Trade (after fees):** {avg_pnl_after_fees:.2f}")
                st.subheader("Cumulative Returns (Equity Curve, after fees)")
                equity = [0]
                for p in trade_profits_after_fees:
                    equity.append(equity[-1] + p)
                equity = equity[1:]
                if equity:
                    equity_df = pd.DataFrame({
                        'trade': list(range(1, len(equity)+1)),
                        'equity': equity
                    })
                    st.line_chart(equity_df.set_index('trade'))
                else:
                    st.info("No equity curve to display.")
                st.subheader("Price and Moving Averages")
                import altair as alt
                chart = alt.Chart(df_bt).mark_line().encode(
                    x='datetime:T',
                    y='close:Q',
                    color=alt.value('blue'),
                    tooltip=['datetime', 'close']
                ).properties(title='Close Price')
                ma20_line = alt.Chart(df_bt).mark_line(color='orange').encode(x='datetime:T', y='ma20:Q')
                ma50_line = alt.Chart(df_bt).mark_line(color='green').encode(x='datetime:T', y='ma50:Q')
                st.altair_chart(chart + ma20_line + ma50_line) 